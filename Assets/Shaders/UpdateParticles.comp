#version 430

struct Particle {
    vec3 Position;
    vec3 PredictedPosition;
    vec3 Velocity;
    vec3 PressureAcceleration;

    float density;
    float pressure;

    uint Gridhash;
};

struct Fence {
    int left;
	int right;
	int bottom;
	int top;
	int front;
	int back;
};

layout(std430, binding = 0) buffer ParticleBuffer {
    Particle particles[];
};

layout(local_size_x = 1024) in;

layout(location = 0) uniform Fence fence;
layout(location = 6) uniform float dt;
layout(location = 7) uniform bool gravityEnabled;
layout(location = 8) uniform vec3 gravity;
layout(location = 9) uniform float particleRadius;
layout(location = 10) uniform float dampingRate;

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= particles.length()) return;

    particles[index].Velocity += particles[index].PressureAcceleration * dt;
    if (gravityEnabled){
        particles[index].Velocity += gravity * dt;
    }
    particles[index].Position += particles[index].Velocity * dt;
    if (particles[index].Position.y >= fence.bottom - particleRadius) {
        particles[index].Position.y = fence.bottom - (0.0001f + particleRadius);
        particles[index].Velocity.y = -particles[index].Velocity.y * dampingRate;
    }
    if (particles[index].Position.y <= fence.top + particleRadius ) {
        particles[index].Position.y = fence.top + (0.0001f + particleRadius);
        particles[index].Velocity.y = -particles[index].Velocity.y * dampingRate;
    }
    if (particles[index].Position.x >= fence.right - particleRadius) {
        particles[index].Position.x = fence.right - (0.0001f + particleRadius);
        particles[index].Velocity.x = -particles[index].Velocity.x * dampingRate;
    }
    if (particles[index].Position.x <= fence.left + particleRadius ) {
        particles[index].Position.x = fence.left + (0.0001f + particleRadius);
        particles[index].Velocity.x = -particles[index].Velocity.x * dampingRate;
    }
    if (particles[index].Position.z >= fence.back - particleRadius ) {
        particles[index].Position.z = fence.back - (0.0001f + particleRadius);
        particles[index].Velocity.z = -particles[index].Velocity.z * dampingRate;
    }
    if (particles[index].Position.z <= fence.front + particleRadius ) {
        particles[index].Position.z = fence.front+ (0.0001f + particleRadius);
        particles[index].Velocity.z = -particles[index].Velocity.z * dampingRate;
    }

    particles[index].PredictedPosition = particles[index].Position + particles[index].Velocity * (1 / 30.0f) + (gravity) * 0.5f * (1 / 30.0f) * (1 / 30.0f);

    particles[index].PredictedPosition.x = clamp(particles[index].PredictedPosition.x, float(fence.left), float(fence.right));
    particles[index].PredictedPosition.y = clamp(particles[index].PredictedPosition.y, float(fence.top), float(fence.bottom));
    particles[index].PredictedPosition.z = clamp(particles[index].PredictedPosition.z, float(fence.front), float(fence.back));


}