#version 430

struct Particle {
    vec3 Position;
    vec3 PredictedPosition;
    vec3 Velocity;
    vec3 PressureAcceleration;

    float density;
    float pressure;

    uint Gridhash;
};

struct Fence {
    int left;
    int right;
    int bottom;
    int top;
    int front;
    int back;
};

layout(std430, binding = 0) buffer ParticleBuffer {
    Particle particles[];
};

layout(std430, binding = 1) buffer HashLookupTable {
    int hashLookupTable[];
};

layout(std430, binding = 2) buffer NeighbourParticlesBuffer {
    int NeighbourParticles[];
};

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(location = 0) uniform float gridSize;
layout(location = 1) uniform int hashFunctionX;
layout(location = 2) uniform int hashFunctionY;
layout(location = 3) uniform int hashFunctionZ;
layout(location = 4) uniform float marchingCubeGridSize;
layout(location = 5) uniform Fence fence;

uint calcHash(ivec3 gridpos) {
    return (uint((gridpos.x * hashFunctionX) ^ (gridpos.y * hashFunctionY) ^ (gridpos.z * hashFunctionZ)) % particles.length());
}

void main() {
    ivec3 index = ivec3(gl_GlobalInvocationID.xyz);
    
    // Expand the grid size vector by one on each side
    ivec3 gridSizeVec = ivec3(((fence.right - fence.left) / marchingCubeGridSize) + 2,
                              ((fence.bottom - fence.top) / marchingCubeGridSize) + 2,
                              ((fence.back - fence.front) / marchingCubeGridSize) + 2);

    // Update bounds checking to account for the expanded grid
    if (index.x >= gridSizeVec.x || index.y >= gridSizeVec.y || index.z >= gridSizeVec.z)
        return;

    vec3 least = vec3(fence.left, fence.top, fence.front);
    // Adjust position calculation to start one grid before
    ivec3 pos = ivec3(least + vec3(index - ivec3(1)) * marchingCubeGridSize);
    ivec3 gridPos = ivec3(pos / gridSize);

    // Precompute the hashes for the neighboring cells
    uint neighborHashes[27];
    int count = 0;
    for (int ix = -1; ix <= 1; ix++) {
        for (int iy = -1; iy <= 1; iy++) {
            for (int iz = -1; iz <= 1; iz++) {
                neighborHashes[count++] = calcHash(gridPos + ivec3(ix, iy, iz));
            }
        }
    }

    int neighborCount = 0;

    // Loop through precomputed hashes and particles
    for (int i = 0; i < 27; i++) {
        uint key = neighborHashes[i];
        int startIndex = hashLookupTable[key];
        for (int j = startIndex; j < particles.length(); j++) {
            Particle neighbor = particles[j];
            if (key != neighbor.Gridhash) break;

            float distance = length(neighbor.Position - vec3(pos));
            if (distance <= gridSize) neighborCount++;
        }
    }

    int dIndex = int(index.x * gridSizeVec.y * gridSizeVec.z + index.y * gridSizeVec.z + index.z);
    NeighbourParticles[dIndex] = neighborCount;
}
